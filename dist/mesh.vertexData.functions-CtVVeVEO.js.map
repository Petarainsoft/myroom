{"version":3,"file":"mesh.vertexData.functions-CtVVeVEO.js","sources":["../node_modules/@babylonjs/core/Misc/bitArray.js","../node_modules/@babylonjs/core/Meshes/mesh.vertexData.functions.js"],"sourcesContent":["function getByteIndex(bitIndex) {\n    return Math.floor(bitIndex / 8);\n}\nfunction getBitMask(bitIndex) {\n    return 1 << bitIndex % 8;\n}\n/**\n * An fixed size array that effectively stores boolean values where each value is a single bit of backing data.\n * @remarks\n * All bits are initialized to false.\n */\nexport class BitArray {\n    /**\n     * Creates a new bit array with a fixed size.\n     * @param size The number of bits to store.\n     */\n    constructor(size) {\n        this.size = size;\n        this._byteArray = new Uint8Array(Math.ceil(this.size / 8));\n    }\n    /**\n     * Gets the current value at the specified index.\n     * @param bitIndex The index to get the value from.\n     * @returns The value at the specified index.\n     */\n    get(bitIndex) {\n        if (bitIndex >= this.size) {\n            throw new RangeError(\"Bit index out of range\");\n        }\n        const byteIndex = getByteIndex(bitIndex);\n        const bitMask = getBitMask(bitIndex);\n        return (this._byteArray[byteIndex] & bitMask) !== 0;\n    }\n    /**\n     * Sets the value at the specified index.\n     * @param bitIndex The index to set the value at.\n     * @param value The value to set.\n     */\n    set(bitIndex, value) {\n        if (bitIndex >= this.size) {\n            throw new RangeError(\"Bit index out of range\");\n        }\n        const byteIndex = getByteIndex(bitIndex);\n        const bitMask = getBitMask(bitIndex);\n        if (value) {\n            this._byteArray[byteIndex] |= bitMask;\n        }\n        else {\n            this._byteArray[byteIndex] &= ~bitMask;\n        }\n    }\n}\n//# sourceMappingURL=bitArray.js.map","import { BitArray } from \"../Misc/bitArray.js\";\n/**\n * Sort (in place) the index array so that faces with common indices are close\n * @param indices the array of indices to sort\n */\nexport function OptimizeIndices(indices) {\n    const faces = [];\n    const faceCount = indices.length / 3;\n    // Step 1: Break the indices array into faces\n    for (let i = 0; i < faceCount; i++) {\n        faces.push([indices[i * 3], indices[i * 3 + 1], indices[i * 3 + 2]]);\n    }\n    // Step 2: Build a graph connecting faces sharing a vertex\n    const vertexToFaceMap = new Map();\n    faces.forEach((face, faceIndex) => {\n        face.forEach((vertex) => {\n            let face = vertexToFaceMap.get(vertex);\n            if (!face) {\n                vertexToFaceMap.set(vertex, (face = []));\n            }\n            face.push(faceIndex);\n        });\n    });\n    // Step 3: Traverse faces using DFS to ensure connected faces are close\n    const visited = new BitArray(faceCount);\n    const sortedFaces = [];\n    // Using a stack and not a recursive version to avoid call stack overflow\n    const deepFirstSearchStack = (startFaceIndex) => {\n        const stack = [startFaceIndex];\n        while (stack.length > 0) {\n            const currentFaceIndex = stack.pop();\n            if (visited.get(currentFaceIndex)) {\n                continue;\n            }\n            visited.set(currentFaceIndex, true);\n            sortedFaces.push(faces[currentFaceIndex]);\n            // Push unvisited neighbors (faces sharing a vertex) onto the stack\n            faces[currentFaceIndex].forEach((vertex) => {\n                const neighbors = vertexToFaceMap.get(vertex);\n                if (!neighbors) {\n                    return;\n                }\n                neighbors.forEach((neighborFaceIndex) => {\n                    if (!visited.get(neighborFaceIndex)) {\n                        stack.push(neighborFaceIndex);\n                    }\n                });\n            });\n        }\n    };\n    // Start DFS from the first face\n    for (let i = 0; i < faceCount; i++) {\n        if (!visited.get(i)) {\n            deepFirstSearchStack(i);\n        }\n    }\n    // Step 4: Flatten the sorted faces back into an array\n    let index = 0;\n    sortedFaces.forEach((face) => {\n        indices[index++] = face[0];\n        indices[index++] = face[1];\n        indices[index++] = face[2];\n    });\n}\n//# sourceMappingURL=mesh.vertexData.functions.js.map"],"names":["getByteIndex","bitIndex","getBitMask","BitArray","size","byteIndex","bitMask","value","OptimizeIndices","indices","faces","faceCount","i","vertexToFaceMap","face","faceIndex","vertex","visited","sortedFaces","deepFirstSearchStack","startFaceIndex","stack","currentFaceIndex","neighbors","neighborFaceIndex","index"],"mappings":"AAAA,SAASA,EAAaC,GAAU;AAC5B,SAAO,KAAK,MAAMA,IAAW,CAAC;AAClC;AACA,SAASC,EAAWD,GAAU;AAC1B,SAAO,KAAKA,IAAW;AAC3B;AAMO,MAAME,EAAS;AAAA;AAAA;AAAA;AAAA;AAAA,EAKlB,YAAYC,GAAM;AACd,SAAK,OAAOA,GACZ,KAAK,aAAa,IAAI,WAAW,KAAK,KAAK,KAAK,OAAO,CAAC,CAAC;AAAA,EAC7D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAIH,GAAU;AACV,QAAIA,KAAY,KAAK;AACjB,YAAM,IAAI,WAAW,wBAAwB;AAEjD,UAAMI,IAAYL,EAAaC,CAAQ,GACjCK,IAAUJ,EAAWD,CAAQ;AACnC,YAAQ,KAAK,WAAWI,CAAS,IAAIC,OAAa;AAAA,EACtD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAIL,GAAUM,GAAO;AACjB,QAAIN,KAAY,KAAK;AACjB,YAAM,IAAI,WAAW,wBAAwB;AAEjD,UAAMI,IAAYL,EAAaC,CAAQ,GACjCK,IAAUJ,EAAWD,CAAQ;AACnC,IAAIM,IACA,KAAK,WAAWF,CAAS,KAAKC,IAG9B,KAAK,WAAWD,CAAS,KAAK,CAACC;AAAA,EAEvC;AACJ;AC9CO,SAASE,EAAgBC,GAAS;AACrC,QAAMC,IAAQ,CAAA,GACRC,IAAYF,EAAQ,SAAS;AAEnC,WAASG,IAAI,GAAGA,IAAID,GAAWC;AAC3B,IAAAF,EAAM,KAAK,CAACD,EAAQG,IAAI,CAAC,GAAGH,EAAQG,IAAI,IAAI,CAAC,GAAGH,EAAQG,IAAI,IAAI,CAAC,CAAC,CAAC;AAGvE,QAAMC,IAAkB,oBAAI,IAAG;AAC/B,EAAAH,EAAM,QAAQ,CAACI,GAAMC,MAAc;AAC/B,IAAAD,EAAK,QAAQ,CAACE,MAAW;AACrB,UAAIF,IAAOD,EAAgB,IAAIG,CAAM;AACrC,MAAKF,KACDD,EAAgB,IAAIG,GAASF,IAAO,CAAA,CAAE,GAE1CA,EAAK,KAAKC,CAAS;AAAA,IACvB,CAAC;AAAA,EACL,CAAC;AAED,QAAME,IAAU,IAAId,EAASQ,CAAS,GAChCO,IAAc,CAAA,GAEdC,IAAuB,CAACC,MAAmB;AAC7C,UAAMC,IAAQ,CAACD,CAAc;AAC7B,WAAOC,EAAM,SAAS,KAAG;AACrB,YAAMC,IAAmBD,EAAM,IAAG;AAClC,MAAIJ,EAAQ,IAAIK,CAAgB,MAGhCL,EAAQ,IAAIK,GAAkB,EAAI,GAClCJ,EAAY,KAAKR,EAAMY,CAAgB,CAAC,GAExCZ,EAAMY,CAAgB,EAAE,QAAQ,CAACN,MAAW;AACxC,cAAMO,IAAYV,EAAgB,IAAIG,CAAM;AAC5C,QAAKO,KAGLA,EAAU,QAAQ,CAACC,MAAsB;AACrC,UAAKP,EAAQ,IAAIO,CAAiB,KAC9BH,EAAM,KAAKG,CAAiB;AAAA,QAEpC,CAAC;AAAA,MACL,CAAC;AAAA,IACL;AAAA,EACJ;AAEA,WAASZ,IAAI,GAAGA,IAAID,GAAWC;AAC3B,IAAKK,EAAQ,IAAIL,CAAC,KACdO,EAAqBP,CAAC;AAI9B,MAAIa,IAAQ;AACZ,EAAAP,EAAY,QAAQ,CAACJ,MAAS;AAC1B,IAAAL,EAAQgB,GAAO,IAAIX,EAAK,CAAC,GACzBL,EAAQgB,GAAO,IAAIX,EAAK,CAAC,GACzBL,EAAQgB,GAAO,IAAIX,EAAK,CAAC;AAAA,EAC7B,CAAC;AACL;","x_google_ignoreList":[0,1]}